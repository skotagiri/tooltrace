// AprilTag detection module
// Implements AprilTag detection using kornia-apriltag

use anyhow::{Context, Result};
use kornia_apriltag::{AprilTagDecoder, DecodeTagsConfig};
use kornia_apriltag::family::TagFamilyKind;
use kornia_image::{Image, ImageSize};
use image::{GenericImageView, Rgb, RgbImage};
use imageproc::drawing::{draw_line_segment_mut, draw_filled_circle_mut, draw_text_mut};
use ab_glyph::{FontRef, PxScale};

pub struct TagDetection {
    pub id: u32,
    pub center: (f64, f64),
    pub corners: [(f64, f64); 4],
    pub hamming_distance: u32,
    pub decision_margin: f64,
}

pub fn detect_apriltags(image_path: &str, debug_output: Option<&str>) -> Result<Vec<TagDetection>> {
    // Load the image using the image crate
    let img_rgb = image::open(image_path)
        .with_context(|| format!("Failed to read image: {}", image_path))?;

    let (orig_width, orig_height) = img_rgb.dimensions();
    println!("Loaded image: {}x{}", orig_width, orig_height);

    detect_apriltags_from_image(&img_rgb.to_rgb8(), debug_output)
}

/// Detect AprilTags from an in-memory image
pub fn detect_apriltags_from_image(img_rgb: &RgbImage, debug_output: Option<&str>) -> Result<Vec<TagDetection>> {
    let (orig_width, orig_height) = img_rgb.dimensions();
    println!("Processing image: {}x{}", orig_width, orig_height);

    // Downsample large images for AprilTag detection to reduce memory usage
    // AprilTags are robust and don't need full resolution
    const MAX_DIMENSION: u32 = 1920;
    let img_rgb_dynamic = image::DynamicImage::ImageRgb8(img_rgb.clone());
    let (img_rgb_resized, scale_factor) = if orig_width > MAX_DIMENSION || orig_height > MAX_DIMENSION {
        let scale = (MAX_DIMENSION as f64 / orig_width.max(orig_height) as f64) as f32;
        let new_width = (orig_width as f32 * scale) as u32;
        let new_height = (orig_height as f32 * scale) as u32;
        println!("Downsampling to {}x{} for detection (scale: {:.2})", new_width, new_height, scale);
        (img_rgb_dynamic.resize(new_width, new_height, image::imageops::FilterType::Lanczos3), scale as f64)
    } else {
        (img_rgb_dynamic.clone(), 1.0)
    };

    let (width, height) = (img_rgb_resized.width(), img_rgb_resized.height());

    // Convert to grayscale
    let img_gray = img_rgb_resized.to_luma8();

    // Convert to kornia Image format
    let kornia_img = Image::new(
        ImageSize {
            width: width as usize,
            height: height as usize,
        },
        img_gray.into_raw(),
        kornia_image::allocator::CpuAllocator,
    )?;

    // Use Tag36H11 family only (generated by our paper-gen)
    let config = DecodeTagsConfig::new(vec![TagFamilyKind::Tag36H11]);

    let img_size = ImageSize {
        width: width as usize,
        height: height as usize,
    };

    // Create decoder and detect tags
    let mut decoder = AprilTagDecoder::new(config, img_size)
        .context("Failed to create AprilTag decoder")?;

    let detections = decoder.decode(&kornia_img)
        .context("Failed to decode AprilTags")?;

    println!("Found {} AprilTag(s)", detections.len());

    // Convert to our TagDetection format and scale back to original image coordinates
    let results: Vec<TagDetection> = detections.iter().map(|det| {
        // Extract corner positions from quad and scale back to original size
        let corners = [
            (det.quad.corners[0].x as f64 / scale_factor, det.quad.corners[0].y as f64 / scale_factor),
            (det.quad.corners[1].x as f64 / scale_factor, det.quad.corners[1].y as f64 / scale_factor),
            (det.quad.corners[2].x as f64 / scale_factor, det.quad.corners[2].y as f64 / scale_factor),
            (det.quad.corners[3].x as f64 / scale_factor, det.quad.corners[3].y as f64 / scale_factor),
        ];

        // Calculate center from corners
        let center_x = corners.iter().map(|(x, _)| x).sum::<f64>() / 4.0;
        let center_y = corners.iter().map(|(_, y)| y).sum::<f64>() / 4.0;

        TagDetection {
            id: det.id as u32,
            center: (center_x, center_y),
            corners,
            hamming_distance: det.hamming as u32,
            decision_margin: det.decision_margin as f64,
        }
    }).collect();

    // Print detection details
    for det in &results {
        println!("  Tag ID {}: center=({:.1}, {:.1}), hamming={}, margin={:.2}",
            det.id, det.center.0, det.center.1, det.hamming_distance, det.decision_margin);
    }

    // Save debug visualization if requested
    if let Some(debug_path) = debug_output {
        save_debug_image(img_rgb, &results, debug_path)?;
    }

    Ok(results)
}

fn save_debug_image(img: &RgbImage, detections: &[TagDetection], output_path: &str) -> Result<()> {
    let mut debug_img = img.clone();

    let rect_color = Rgb([0u8, 255u8, 0u8]); // Green rectangles
    let corner_color = Rgb([255u8, 0u8, 0u8]); // Red corners
    let center_color = Rgb([0u8, 0u8, 255u8]); // Blue center
    let text_color = Rgb([255u8, 255u8, 0u8]); // Yellow text

    // Use embedded Noto Sans font from ab_glyph
    let font = FontRef::try_from_slice(include_bytes!("../../fonts/NotoSans-Regular.ttf"))
        .context("Failed to load font")?;

    let scale = PxScale::from(40.0); // Font size

    for det in detections {
        // Draw lines connecting the corners to form the quad
        for i in 0..4 {
            let next = (i + 1) % 4;
            let p1 = (det.corners[i].0 as f32, det.corners[i].1 as f32);
            let p2 = (det.corners[next].0 as f32, det.corners[next].1 as f32);
            draw_line_segment_mut(&mut debug_img, p1, p2, rect_color);
        }

        // Draw corners as circles
        for corner in &det.corners {
            draw_filled_circle_mut(
                &mut debug_img,
                (corner.0 as i32, corner.1 as i32),
                8,
                corner_color
            );
        }

        // Draw center point
        draw_filled_circle_mut(
            &mut debug_img,
            (det.center.0 as i32, det.center.1 as i32),
            12,
            center_color
        );

        // Draw tag ID as text near the center
        let text = format!("ID {}", det.id);
        let text_x = (det.center.0 as i32) + 20; // Offset to the right
        let text_y = (det.center.1 as i32) - 20; // Offset up
        draw_text_mut(&mut debug_img, text_color, text_x, text_y, scale, &font, &text);

        println!("  Annotated Tag ID {} at ({:.1}, {:.1})", det.id, det.center.0, det.center.1);
    }

    // Save the annotated image
    debug_img.save(output_path)
        .with_context(|| format!("Failed to save debug image to {}", output_path))?;

    println!("Debug image saved to: {}", output_path);
    Ok(())
}
